# C++ 复习笔记

## 第二章 C++的简单程序设计

### 基本的输入输出流

```cpp
cin >> a >> b;
cout << "NIce" << endl;
```

常用的IO流操作符

| 操作符名            | 含义                                                         |
| ------------------- | ------------------------------------------------------------ |
| `senprecision(int)` | 设置浮点数的小数位数 包括小数点 会进行四舍五入<br />需要引入 `iomanip`头文件 |
| `setw(int)`         | 设置域宽                                                     |
| `endl`              | 插入换行符并刷新流                                           |



## 第三章 函数

### 函数的参数传递

- 函数在调用时才分配形参的存储单元
- 值传递是传递参数值，即**单向传递**
- 引用传递可以实现**双向传递**
- 常引用作参数可以保障实参数据的安全



#### 内联函数

关键字 `inline`

编译时在调用处用函数体进行替换，节省了参数传递、控制转移等开销

:warning:

- 内联函数体内不可以有 **循环语句** 和 **switch** 语句
- 内联函数的声明必须出现在内联函数第一次被调用之前
- 对内联函数不能进行异常接口声明



### 函数重载

> 两个以上的函数，具有相同的函数名，但是形参的数量或者类型不同





## 第四章 类与对象

### 基本概念

#### 抽象

面向对象中的抽象，指对具体问题或对象进行概括，抽出一类对象的公共性质并加以描述的过程

#### 封装

封装就是将抽象得到的数据和行为或功能进行结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合

#### 类

程序模块是由类构成的，类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述

#### 对象

对于一个类的一个特定实体，就是一个对象



### 类的定义格式

```cpp
class Clock {
public:
	void setTime(int newH, int newM)    ;
    void showTime();
private:
    int hour,minute,second;
};
```



### 类的访问控制

访问权限控制符可以是以下三个中的一个 

- `public`
- 公有类型成员定义了类的外部接口
- `private`
- 私有成员只能被本类的成员函数访问，来自类外部的任何访问都是违法的
- `protected`
  - 性质与 `private` 类似，区别在于**继承**过程中它的性质发生的变化



### 类成员函数的定义

#### 成员函数的实现

```cpp
void Clock::showTime(){
    cout << hour << minute << second << endl;
}
```



#### 内联成员函数

```cpp
class Clock {
public:
    // 隐式的内联函数
    void showTime(){
        cout << hour << minute << second << endl;
    }
};

// 显式的内联函数
inline void Clock::showTime(){
    cout << hour << minute << second << endl;
}
```





###  多态

> 一段程序能够处理多种类型对象的能力
>
> 强制多态、重载多态、类型参数化多态、包含多态
>
> 4 种方式来实现

- 强制多态
  - 将一种类型的数据转换成另外一个类型的数据来实现的
- 重载多态
  - 同一个名字赋予不同的含义 如函数重载，运算符重载
- 包含多态
  - 虚函数`virtual`实现
- 类型参数化多态
  - 模板`template`实现





### 构造函数

构造函数没有返回值，通常被声明为`public`类型

#### 复制构造函数

其功能是根据当前已经存在的一个对象，获取对象中的数据并生成一个新的对象



### 析构函数

它是用来完成对象被删除之前的一些清理工作的

析构函数是在对象的生存期即将结束的时刻被自动调用的

它**不接受任何参数**



**析构函数的调用执行顺序于构造函数正好相反**



### 结构体

默认不声明访问的权限属性的时候，结构体的默认权限是`public`而类中为`private`

两者在功能上完全一致，引入是因为向下兼容`C`语言



### 联合体

联合体是一种特殊的类，它可以有自己的数据成员和函数成员，可以有自己的构造函数和析构函数

**联合体也是从C语言继承过来的，联合体内的全部数据成员共享同一组内存单元**

联合体变量中的成员至多只有一个是有意义的



#### 访问权限的控制

`protected` 类型与当前类中 `public`的访问权限一致，但是去区别在于继承的时候产生的结果不同

**修饰访问权限的关键字可以多次出现，但是一个成员只能有一种访问权限**



## 第五章 数据的共享与保护

### 作用域

#### 函数原型作用域

```cpp
double area(double radius){
    // radius 变量的作用域就只在这个花括号内了
}
```



#### 局部作用域

函数体内声明的变量，其作用域从声明除开始，一直到声明所在的块结束的大括号为止



#### 类作用域

- 在类中访问
- `x.m` 或 `X::m`
- `ptr->m`指针访问



#### 命名空间作用域

```cpp
namespace Demo {
    // someting here...
}
```

一般都会使用 

```cpp
using namespace std;
```





### 静态成员

类的静态成员是解决**一个类的不同对象之间的数据和函数共享**问题的

```cpp
class clock {
    public:
    static int count;
};

int main(){
    int clock::count = 0;
}
```





### 静态成员函数

静态成员函数可以直接访问该类的静态数据和成员函数，而访问非静态成员，必须通过对象名

```cpp
class A {
    public:
    static void f(A a);
}
void A::f(A a){
    cout << x; // Error
    cout << a.x // Nice !
}
```





### 常对象

常对象**只能调用它的常成员函数**



#### 常成员函数

- 使用`const`关键字说明的函数
- 常成员函数不更新对象的数据成员
- `const`关键字可以被用于参与对重载函数的区分

```cpp
void print() const;
```



:warning:

> `const`是函数类型的一个组成部分，在函数的定义部分也需要带 `const` 关键字
>
> 只能够由常对象调用常成员函数
>
> 常成员函数不能够更新对象的数据成员
>
> `const`能够用来进行函数重载



#### 常数据成员

- 使用`const`关键字说明的数据成员



### 常引用

- 常引用的对象不能被更新
- 如果用常饮用做形参，则不会意外地发生对实参的更改
- `const TYPE &name`



## 第六章 指针与字符串

### 数组

数组元素在内存中顺次存放，它们的地址是连续的

数组名字是数组首元素的内存地址

数组名是一个常量，不能被赋值

静态数组只初始化一次，对大型数组可以提高运行效率



#### 对象数组

```cpp
Location a[3] = {Location(1,2), Location(3,4)};
// 第三个对象会自动调用默认构造函数
```





### 指针

内存空间的访问方式

- 通过变量名
- 通过地址访问

允许声明一个`void`类型的指针，该指针可以指向任何一种类型的数据的地址



#### 对象指针

```cpp
Point *ptr;
ptr->getX();
(*ptr).getX();
// 上述两种调用方式是等价的
```



### 动态内存分配

```cpp
int * point = new int();
delete point;
```



### this指针

类的内部都有一个未显示声明的`this`指针

该指针指向当前的对象

通过返回`this`指针可以进行链式调用





## 第七章 继承与派生

### 基本含义

类的继承，是新的类从已有的类那么得到已有的特性

从另一个角度来看，从已有类产生新类的过程就是类的派生



#### 继承的过程

1. 吸收基类成员

   > 派生类包含了基类中除构造和析构函数外的所有成员

2. 改造基类成员

   > 基类成员的访问权限更改
   >
   > 若有不满足重载的同名函数，则会覆盖基类中的同名函数

3. 添加新的成员

   > 派生类也可以新增数据成员和成员函数等
   >
   > 以及构造函数和析构函数





### 继承方式的权限

一句话 : 

> 基类中的 `public` 和 `protected` 成员都将按照继承时设定的权限继承过来，`private`仍为`private`



### 类型兼容规则

类型兼容规则是指在需要基类对象的任何地方，都可以使用共有派生类的对象来替代

在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员



### 派生类的构造和析构函数

#### 构造函数

构造派生类的对象时，就需要对基类的成员对象和新增成员对象进行初始化

1. 调用基类构造函数，调用顺序按照被继承时的顺序
2. 派生类新增的成员对象进行初始化，调用顺序按照在类中定义的顺序
3. 执行派生类的构造函数体中的内容



### 多继承的二义性

如果某派生类的多个基类拥有同名的成员，同时，派生类又新增这样的同名函数，此时派生类成员将隐藏所有基类的同名函数



若派生类中没有重名的成员变量或函数，此时若声明的时候使用该变量或函数，会发生错误



使用`::`作用域分别符可以解决这个问题



```cpp
class Base0{
    public:
    int var0;
    void fun0(){
        cout << "Base 0" << endl;
    }
};

class Base1 {
    public:
    int var0;
    void fun0(){
        cout << "Base 0" << endl;
    }
}

class Derived:public Base1, public Base0 {
    
}

int main(){
    Derived d;
    d.var0 = 0; // Error 
    d.Base0::var0 = 2; // Ok
    d.Base1.fun0(); // Ok
}
```



### 虚基类

如上所示，需要通过作用域分辨符进行访问

当然也可以将基类设置为 **虚基类** 这时从不同的路径继承过来的同名数据成员在内存中就只有一个副本，同一个函数名也只有一个映射



```cpp
class Base0{
    public:
    int var0;
    void fun0(){
        cout << "Base 0" << endl;
    }
};

class Base1: virtual public Base0{
    public:
    int var1;
    void fun0(){
        cout << "Base 0" << endl;
    }
};

class Base2: virtual public Base0{
  public:
    int var2;
    void fun2(){}
};

class Derived: public Base2, public Base1{
  public:
    int var0;
    void fun(){
        cout << "Derived" << endl;
    }
};

int main(){
    Derived d;
    d.var0 = 2; // Ok
    d.fun0(); //  OK
}
```





## 第八章 多态性

### 多态性的含义

同样的消息被不同类型的对象接收时导致不同的行为

即类的成员被调用时，有不同的实现方法



根据多态实现的不同，可以分为两类

- 编译时的多态
  - 在编译时就确定了重名操作的具体操作对象
- 运行时的多态
  - 程序运行时才能确定
  - 这种确定的过程就是 **绑定**
  - 绑定在编译阶段完成叫做 **静态绑定** 在程序运行阶段完成叫做 **动态绑定**



### 动态联编的含义

编译程序在编译阶段并不能确切地指导将要调用的函数，只有在程序执行时才能确定将要调用的函数

为此要确切地指导将要调用的函数，要求联编工作在程序运行时进行

这种在程序运行时进行的联编工作被称为动态联编，或称动态束定，又叫晚期联编。



### 运算符重载的实质

运算符重载的实质是 **函数的重载**

规则如下

> 1. 除`.` `.*` `::` `?:` 之外都可以重载 且只能重载已有的
> 2. 优先级和结合性不会发生改变



### 运算符重载的形式

#### 成员函数

```cpp
class Complex {
  public:
    Complex operator + (const Complex &c2) const;
    
    Complex operator ++ ();		// 前置单目运算符
    Complex operator ++ (int);	// 后置单目运算符
};

Complex Complex::operator + (const Complex &c2) const {
    return // 在这实现
}

// 注意区分前置和后置返回的值

Complex Complex::operator++ (){
    // something here
    return *this;
}

Complex Complex::operator++ (int) {
    Complex old = *this;
    ++(*this);
    return old;
}
```





#### 非成员函数

```cpp
#include <ostream>

ostream & operator << (ostream &out, const Complex &c){
    out << c.real << c.imag << endl;
    return out;
}

int main(){
    Complex c(1,2);
    cout << c; // Ok
}
```







### 虚函数

**虚函数是动态绑定的基础 虚函数必须是非静态的成员函数**

**构造函数不能是虚函数，析构函数可以是虚函数**



虚函数声明只能出现在类中的函数原型声明中，不能在成员函数实现的时候



运行过程中的多态需要满足三个条件

1. 类之间满足赋值兼容原则
2. 声明虚函数
3. 由成员函数调用或者指针、引用来访问虚函数



**基类中声明的虚函数，一般是希望派生类修改基类的函数行为**

**只有通过基类的指针或引用调用虚函数时，才会发生动态绑定**

> 基类的指针可以指向派生类的对象，基类的引用可以作为派生类对象的别名
>
> 但基类的对象却不能表示派生类的对象



### 纯虚函数

```cpp
virtual void Demo(int i) = 0;
```



声明为纯虚函数之后，基类中就可以不再给出函数的实现部分

> 基类中仍可以给出，但是派生类中仍需要覆盖



### 抽象类

带有纯虚函数的类是抽象类

**抽象类不能实例化** 即不能定义一个抽象类的对象，但是可以定义一个抽象类的指针



> 抽象类的作用是通过它为一个类族建立一个公共的接口，使他们能够更有效的发挥多态特性

