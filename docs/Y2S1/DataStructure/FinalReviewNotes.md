# 数据结构 期末 针对性复习点

以下内容仅会针对期末已有的提纲内容进行针对性的补充和阐述



## 知识梳理

### 栈与队列的特点和区别

#### 栈 Stack

`Last In First Out` 后进先出

##### 栈顶 Top

允许进行插入和删除的一端

##### 栈底 Bottom

不允许进行删除和插入的另一端

> `n` 个不同元素进栈，出栈元素的不同排列的个数为
> $$
> Catalan Number = \frac{1}{n+1}C^n_{2n}
> $$
> 



#### 队列 Queue

`First In First Out` 先进先出

##### 队头 Fron

允许删除的一端

##### 队尾 Rear

允许插入的一端



### 栈的操作

参考例题



### 分块查找的特点

#### 分块的查找的特点

既有动态结构，又适用于快速查找

每个分块内的元素可以无序

但是不同的块之间是有序的



即第`n`块中最大的关键字要小于第`n+1`块中所有的关键字

并以此建立一个索引表，索引表中包含

> 各块的最大关键字
>
> 各块中第一个关键字的地址



#### 分块查找的平均查找长度

设索引查找和块内查找的平均查找长度分别为 $L_1,L_2$

对长度为`n`的查找表均匀的分成`b`块，每块包含`s`个记录，均使用顺序查找
$$
ASL = L_1 + L_2 = \frac{b+1}{2} + \frac{s+1}{2} = \frac{s^2 + 2s + n}{2s}
$$
此时，若 $s=\sqrt{n}$ 时，平均查找长度取得最小值，为 $\sqrt{n} + 1$

若对索引表使用折半查找
$$
ASL = L_1 + L_2 = \lceil log_2(b+1) \rceil + \frac{s+1}{2}
$$




#### 分块查找的步骤

1. 在索引表中确定待查记录所在的块 可以进行顺序查找或折半查找
2. 在块内顺序查找



### 完全二叉树的存储

#### 顺序存储结构

即用一组连续的存储单元依次自上而下，自左到右存储完全二叉树上的节点元素

根据二叉树的性质，**完全二叉树和满二叉树**采用该种存储方式非常合适，能唯一地反应节点之间的逻辑关系，也能够最大可能的节省存储空间



#### 链式存储结构

一般对于某个节点，其包含三个域

- 数据域 `Data`
- 左指针域 `LChild`
- 右指针域 `RChild`

**在含有`n`个节点的二叉链表中，含有`n+1`个空链域**



### 线性表顺序存储的特点

线性表的顺序存储又称 **顺序表**

它是用一组地址连续的存储单元依次存储线性表中的数据元素

- **逻辑顺序与物理顺序相同**
  - 因此插入和删除元素需要移动大量元素

- **随机访问** 
  - 获取任一元素的时间复杂度为 $O(1)$

- **存储密度高**
  - 每个节点只存放数据元素



### 循环队列的判空判满条件

循环队列即把顺序队列臆造为一个环状的空间，把存储队列元素的表从逻辑上视为一个**环**

当队首指针 `Q.front = MaxSize -1` 后 再前进一个位置就自动到 `0` 可以用取余运算实现

> - 初始状态
>   - `Q.front = Q.rear = 0`
> - 队首指针前进`1`位
>   - `Q.front = (Q.front + 1) % MaxSize`
> - 队尾指针前进`1`位
>   - `Q.rear = (Q.rear + 1) % MaxSize`
> - 队列长度
>   - `(Q.rear + MaxSize - Q.front) % MaxSize`



#### 判空条件

**`Q.front == Q.rear`**



#### 判满条件

若入队速度快于出队的速度，则队尾指针很快就会追上队首指针，此时仍满足判空的条件，而当下并不为空

对于这种问题，有三种处理方式



1. 牺牲一个单元来进行区分队空和队满 **最为普遍的一种做法**

   即入队时少用一个单元空间，约定 **队头指针在队尾指针的下一位置作为队满的标志**

   - 队满条件 : `(Q.rear + 1) % MaxSize == Q.front`
   - 队空条件 : `Q.front == Q.rear`
   - 队列中元素个数 : `(Q.rear - Q.front + MaxSize) % MaxSize`

2. 类型中增加标识元素个数的数据成员`size`

   - 队空条件 : `Q.size == 0`
   - 队满条件 : `Q.size == MaxSize`

   然而这两种情况都满足 `Q.front == Q.rear`

3. 类型中增加 `tag` 数据成员

   - `tag` 为 0 时 若因删除导致 `Q.front == Q.rear` 则为队空
   - `tag` 为 1 时 若音插入导致 `Q.front == Q.rear` 则为队满



### 邻接矩阵特点与边的关系

用一二维矩阵存储图中边之间的信息

基础部分不做赘述

> - 无向图的邻接矩阵是 **对称矩阵** 对规模较大的邻接矩阵可以进行压缩存储
>
> - 邻接矩阵的 空间复杂度为 $O(n^2)$ 其中 `n`为边的顶点个数

邻接矩阵的特点如下

- 无向图的邻接矩阵一定是一个对称矩阵 **且唯一** 因此 实际存储邻接矩阵时只需要存储 **上\下三角矩阵的元素**
- 很容易确定图中任意两个顶点之间是否有边相连。但是要确定图中一共有多少边，需要进行遍历，花费的时间很大
- **稠密图** 适合使用邻接矩阵的存储表示



### 广义表的表头与表尾



### 二叉排序树的插入、构造、删除

`Binary Sort Tree`

> - 若左子树非空，则左子树上所有节点的值均小于根节点的值
> - 若右子树非空，则右子树上所有节点的值均大于跟节点的值
> - 左、右子树也分别是一棵二叉排序树
>
> 因此对二叉排序树进行 **中序遍历** 可以得到一个递增的有序序列



#### 二叉排序树的查找

从根节点开始进行比对，若小于则在左子树上继续重复上述过程，若大于则在右子树上重复上述过程

显然这个过程是递归的，但是仍可以用非递归的思路写

```java
public BSTNode BSTSearch(BSTNode root, int key){
    BSTNode currentNode = root;
    while(currentNode != null && currentNode.value != key){
        if(key < currentNode.value) currentNode = currentNode.getLeft();
        else currentNode = currentNode.getRight();
    }
    return root;
}
```



#### 二叉排序树的插入

二叉排序树是一种动态树表，其结构通常不是一次生成的，而是在查找过程中，当树中不存在给定值时再进行插入的



- 若原二叉树为空，则直接插入节点
- 若不为空
  - 关键字小于根节点值，则插入到左子树
  - 关键字大于根节点值，则插入到右子树



插入的节点一定时一个新添加的叶节点



#### 二叉排序树的建立

从空树出发，依次把所有的元素插入到二叉排序树中合适的位置



#### 二叉排序树的删除

根据待删除节点的位置，分几种情况处理



- 若节点是叶节点，则直接删除
- 若该节点有一棵左子树或右子树，则让子树成为该节点的父节点的子树，即替代该节点
- 若节点同时有左右子树，则令该节点的 **直接后继 \ 直接前驱** 替代该节点，接着从二叉排序树中删除这个 **直接后继 \ 直接前驱** 就转换成了上述的两种情况之一



#### 二叉排序树的查找效率分析

二叉排序树的查找效率主要取决于 **树的高度**

若二叉排序树的左右子树高度差不超过 `1` 则称为平衡二叉树 此时平均查找长度为 $O(log_2n)$

若是只有左或右孩子的单支树 则平均查找长度为 $O(n)$

对于确定的一个二叉排序树，等概率的平均查找长度为
$$
ASL = \frac{ \sum\limits^h_{i=1} (i*n_i)} {n_{all}}
$$
其中

- $h$ 表示树的高度
- $n_i$表示第$i$个高度下有的节点个数
- $n_{all}$表示所有节点的个数



从查找过程上看，二叉排序树与二分查找类似

就平均时间性能而言，二叉排序树和二分查找差不多

但是二分查找的判定树是唯一的，而二叉排序树的查找不唯一





### 线性探测解决冲突的步骤和思路

散列函数的解决冲突的方法大致上分为两类，**开放地址法** **拉链法**

其中线性探测法属于第一种中的一种

开放地址法中，其数学推导公式为
$$
H_i = (H(key) + d_i) \% m
$$
其中 $H(key)$ 为散列函数 $i= 0,1,2,\cdots ,k(k \leq m-1)$  ; $m$ 表示散列表表长 ; $d_i$ 为增量序列



- 线性探测法

  > 当 $d_i = 0,1,2, \cdots , m-1$ 时 称为线性探测法
  >
  > 特点 : 当冲突发生时，顺序查看表中的下一个单元 当探测到表尾地址 `m-1` 时下一个探测地址是表首地址 `0`
  >
  > 线性探测可能会让 第 `i` 个散列地址的同义词存入第 `i+1` 个散列地址的元素的地址，本应该存入`i+1` 个散列地址的元素就争夺第 `i+2` 个散列地址的元素的地址
  >
  > 从而造成大量元素再相邻的散列地址上 **聚集** 起来，大大降低了查找效率
  >
  > 



:warning: 注意

> 开放地址的情况下，不能随意删除表中的已有元素
>
> 若删除则会截断其他具有相同散列地址的元素的查找地址
>
> 因此要删除一个元素时，应做一个标记，做逻辑删除
>
> 但这样做的副作用会使表看起来很满，实际上仍有许多空间未利用
>
> 因此需要定期维护散列表，把删除标记的元素进行物理删除



### 排序方法的效率以及初始状态相关性



|   算法种类   | 时间复杂度 - Best | 时间复杂度 - Average | 时间复杂度 - Worst |  空间复杂度   | 是否稳定 | 初始状态相关性 | 适用性                     |
| :----------: | :---------------: | :------------------: | :----------------: | :-----------: | :------: | :------------: | -------------------------- |
| 直接插入排序 |      $O(n)$       |       $O(n^2)$       |      $O(n^2)$      |    $O(1)$     |   Yes    |    Related     | 线性表的顺序存储和链式存储 |
|   冒泡排序   |      $O(n)$       |       $O(n^2)$       |      $O(n^2)$      |    $O(1)$     |   Yes    |    Related     |                            |
| 简单选择排序 |     $O(n^2)$      |       $O(n^2)$       |      $O(n^2)$      |    $O(1)$     |    No    |   Irrelevant   |                            |
|   希尔排序   |         -         |          -           |         -          |    $O(1)$     |    No    |       -        | 仅适用于线性表顺序存储     |
|   快速排序   |  $O(n\log_2 n)$   |    $O(n\log_2 n)$    |      $O(n^2)$      | $O(\log_2 n)$ |    No    |    Related     |                            |
|    堆排序    |  $O(n\log_2 n)$   |    $O(n\log_2 n)$    |   $O(n\log_2 n)$   |    $O(1)$     |    No    |   Irrelevant   |                            |
| 2路归并排序  |  $O(n\log_2 n)$   |    $O(n\log_2 n)$    |   $O(n\log_2 n)$   |    $O(n)$     |   Yes    |   Irrelevant   |                            |
|   基数排序   |    $O(d(n+r))$    |     $O(d(n+r))$      |    $O(d(n+r))$     |    $O(r)$     |   Yes    |    Related     |                            |



与初始状态无关的四种算法

> 一堆（**堆排序**）乌龟（**归并排序**）选（**选择排序**）基（**基数排序**）友。



### 单链表有无头节点的判空条件及相关操作和特点

#### 头指针与头节点的区分

以下内容需要有对 `C \ C++` 语言中指针的理解，用`Java`不太好理解

一般是使用 头指针 来表示一个单链表 ，若头指针为 `NULL` 时表示空表

一般会在 **第一个节点之前添加一个头节点** 该节点 **不存储任何数据 仅有指针域**

头指针指向该头节点

引入头节点的好处有2点

- 操作链表的第一个数据节点与操作其他节点是一致的，不需要做特别的处理
- 无论链表是否为空，头节点都是指向头节点的非空指针 （空表 中 头节点的指针域为 `NULL` ）因此空表和非空表的操作是统一的



#### 有关操作

|  操作名称  | 时间复杂度 | 备注                 |
| :--------: | ---------- | -------------------- |
| 按序号查找 | $O(n)$     |                      |
|  按值查找  | $O(n)$     |                      |
|  插入节点  | $O(n)$     | 主要时间消耗在查找上 |
|  删除节点  | $O(n)$     | 主要时间消耗在查找上 |
|   求表长   | $O(n)$     | 遍历                 |



### 线性表在链式\顺序存储下的特点和增删查的效率

#### 顺序存储

**逻辑顺序与其物理顺序相同**

随机读取



| 操作 | 时间复杂度 - Best | 时间复杂度 - Average | 时间复杂度 - Worst |
| :--: | :---------------: | :------------------: | :----------------: |
| 插入 |      $O(1)$       |        $O(n)$        |       $O(n)$       |
| 删除 |      $O(1)$       |        $O(n)$        |       $O(n)$       |
| 查找 |      $O(1)$       |        $O(n)$        |       $O(n)$       |



#### 链式存储

插入删除不需要移动元素，但也失去了随机存取的特点

因为其每个节点至少需要 **数据域 + 指针域** 因此消耗的空间比顺序存储大一些

其操作和时间复杂度等请参考上方 [链式存储的操作相关](#有关操作)



### Huffman树的节点数问题

- Huffman 树种不存在 度为 `1` 的结点
- 若有`n`个节点待构建成`Huffman`树 最后构建完的总节点数为 `2n-1`



### 顺序查找的特点

这种查找非常的直观且很容易实现

即从头开始找到尾，这意味着顺序查找可以在顺序表也可以在链式表中使用

这里强调一下 **哨兵** 的作用

将所有待查找元素的前面放置一个 **哨兵**

顺序查找的时候从后往前找，不必担心数组是否会越界的问题



其平均查找长度如下

对于有`n`个元素的表，给定值`key`与表中第`i`个元素的值相等，即定位到第`i`个元素时，需进行`n-i+1`值的比较， $C_i = n-i+1$
$$
ASL_{success} = \sum^n_i P_i(n-i+1)
$$
当每个元素被查找到的概率都相等 即 $P_i = \frac{1}{n}$ 时 有
$$
ASL_{success} = \sum^n_i P_i(n-i+1) = \frac{n+1}{2}
$$
显然
$$
ASL_{failure} = n +1
$$


#### 有序表的顺序查找

若在查找之前已知表中的关键字为有序，则对于表中没有的数据值，即查找失败的处理会比上述的方法查找的长度减小很多

若每个值的查找概率相等
$$
ASL_{failure} = \sum^n_{j=1}q_i(l_j-1)= \frac{n}{2} + \frac{n}{n+1}
$$




### 图的 DFS BFS 与树的遍历方式的联系

#### Breadth First Search 广度优先搜索

类似于 二叉树的 **层序遍历算法**



#### Depth First Search 深度优先搜索

类似于树的 **先序遍历**





### 插入\选择\交换排序的特点

对于具体算法的复杂度等请参考 [排序算法复杂度](#排序方法的效率以及初始状态相关性)

#### 插入排序

插入排序是一种简单直观的排序方法

基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排序好的子序列中

包含三个重要的算法

- 直接插入排序
- 折半插入排序
- 希尔排序



#### 选择排序

基本思想是每第`i`趟在后面 `n-i+1` 个待排序元素中选取关键字最小的元素，作为有序序列的第`i`的元素

直到第 `n-1`趟完成 

其中有 **堆排序** **简单选择排序**



#### 交换排序

所谓交换，指的是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置

基于交换的排序算法很多，书中介绍了 **冒泡排序** 和 **快速排序**



### 稀疏矩阵的三元组

矩阵中非零元素的个数`t` 相对矩阵元素的个数 `s` 来说非常少 即 `s >> t` 的矩阵成为稀疏矩阵

若采用常规的方法存储稀疏矩阵，则非常的浪费空间

因此仅存储非零元素 

但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储其所在的行和列

因此可以使用 三元组（行标，列标，值）的方式存储

既可以采用数组存储，也可以使用十字链表法存储

二维数组在这不做赘述

---

对于十字链表法，每个节点可设置其域为`(row,col,value),down,right`

其中`(row,col,value)`即为三元组的三个值

`down` 指向同列·中相邻行的下一个节点

`right` 指向同行中相邻列的下一个节点

其牺牲了空间换来了一定的效率



### 二叉树遍历结果进行还原

可以确定唯一的二叉树

- 后序序列 中序序列

> 



- 先序序列 中序序列







## 习题归纳

### 栈

