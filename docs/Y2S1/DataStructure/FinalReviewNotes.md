---
password: imbaNOt3s
---

# 数据结构 期末 针对性复习点

以下内容仅会针对期末已有的提纲内容进行针对性的补充和阐述



## 知识梳理

### 栈与队列的特点和区别

#### 栈 Stack

`Last In First Out` 后进先出

##### 栈顶 Top

允许进行插入和删除的一端

##### 栈底 Bottom

不允许进行删除和插入的另一端

> `n` 个不同元素进栈，出栈元素的不同排列的个数为
> $$
> Catalan Number = \frac{1}{n+1}C^n_{2n}
> $$
> 



#### 队列 Queue

`First In First Out` 先进先出

##### 队头 Fron

允许删除的一端

##### 队尾 Rear

允许插入的一端



### 栈的操作

参考例题



### 分块查找的特点

#### 分块的查找的特点

既有动态结构，又适用于快速查找

每个分块内的元素可以无序

但是不同的块之间是有序的



即第`n`块中最大的关键字要小于第`n+1`块中所有的关键字

并以此建立一个索引表，索引表中包含

> 各块的最大关键字
>
> 各块中第一个关键字的地址



#### 分块查找的平均查找长度

设索引查找和块内查找的平均查找长度分别为 $L_1,L_2$

对长度为`n`的查找表均匀的分成`b`块，每块包含`s`个记录，均使用顺序查找
$$
ASL = L_1 + L_2 = \frac{b+1}{2} + \frac{s+1}{2} = \frac{s^2 + 2s + n}{2s}
$$
此时，若 $s=\sqrt{n}$ 时，平均查找长度取得最小值，为 $\sqrt{n} + 1$

若对索引表使用折半查找
$$
ASL = L_1 + L_2 = \lceil log_2(b+1) \rceil + \frac{s+1}{2}
$$




#### 分块查找的步骤

1. 在索引表中确定待查记录所在的块 可以进行顺序查找或折半查找
2. 在块内顺序查找



### 完全二叉树的存储

#### 顺序存储结构

即用一组连续的存储单元依次自上而下，自左到右存储完全二叉树上的节点元素

根据二叉树的性质，**完全二叉树和满二叉树**采用该种存储方式非常合适，能唯一地反应节点之间的逻辑关系，也能够最大可能的节省存储空间



#### 链式存储结构

一般对于某个节点，其包含三个域

- 数据域 `Data`
- 左指针域 `LChild`
- 右指针域 `RChild`

**在含有`n`个节点的二叉链表中，含有`n+1`个空链域**



### 线性表顺序存储的特点

线性表的顺序存储又称 **顺序表**

它是用一组地址连续的存储单元依次存储线性表中的数据元素

- **逻辑顺序与物理顺序相同**
  - 因此插入和删除元素需要移动大量元素

- **随机访问** 
  - 获取任一元素的时间复杂度为 $O(1)$

- **存储密度高**
  - 每个节点只存放数据元素



### 循环队列的判空判满条件

循环队列即把顺序队列臆造为一个环状的空间，把存储队列元素的表从逻辑上视为一个**环**

当队首指针 `Q.front = MaxSize -1` 后 再前进一个位置就自动到 `0` 可以用取余运算实现

> - 初始状态
>   - `Q.front = Q.rear = 0`
> - 队首指针前进`1`位
>   - `Q.front = (Q.front + 1) % MaxSize`
> - 队尾指针前进`1`位
>   - `Q.rear = (Q.rear + 1) % MaxSize`
> - 队列长度
>   - `(Q.rear + MaxSize - Q.front) % MaxSize`



#### 判空条件

**`Q.front == Q.rear`**



#### 判满条件

若入队速度快于出队的速度，则队尾指针很快就会追上队首指针，若此时判空结果为`true`，而当下并不为空

对于这种问题，有三种处理方式



1. 牺牲一个单元来进行区分队空和队满 **最为普遍的一种做法**

   即入队时少用一个单元空间，约定 **队头指针在队尾指针的下一位置作为队满的标志**

   - 队满条件 : `(Q.rear + 1) % MaxSize == Q.front`
   - 队空条件 : `Q.front == Q.rear`
   - 队列中元素个数 : `(Q.rear - Q.front + MaxSize) % MaxSize`

2. 类型中增加标识元素个数的数据成员`size`

   - 队空条件 : `Q.size == 0`
   - 队满条件 : `Q.size == MaxSize`

   然而 `Q.front == Q.rear` 在这两种情况下都成立

3. 类型中增加 `tag` 数据成员

   - `tag` 为 0 时 若因删除导致 `Q.front == Q.rear` 则为队空
   - `tag` 为 1 时 若音插入导致 `Q.front == Q.rear` 则为队满



### 邻接矩阵特点与边的关系

用一二维矩阵存储图中边之间的信息

基础部分不做赘述

> - 无向图的邻接矩阵是 **对称矩阵** 对规模较大的邻接矩阵可以进行压缩存储
>
> - 邻接矩阵的 空间复杂度为 $O(n^2)$ 其中 `n`为边的顶点个数

邻接矩阵的特点如下

- 无向图的邻接矩阵一定是一个对称矩阵 **且唯一** 因此 实际存储邻接矩阵时只需要存储 **上\下三角矩阵的元素**
- 很容易确定图中任意两个顶点之间是否有边相连。但是要确定图中一共有多少边，需要进行遍历，花费的时间很大
- **稠密图** 适合使用邻接矩阵的存储表示



### 广义表的表头与表尾

广义表是线性表的推广，最为常见的广义表如 `Lisp` 语言

一般广义表记作
$$
LS = (a_1, a_2, a_3, \cdots , a_n)
$$

- $LS$ 称作广义表的名称
- $n$ 为广义表的长度

与线性表不同的是，$a_n$ 本身也可以是一个元素也可以是一个广义表

分别成为广义表的 **原子** 和 **子表**

习惯上，用大写字母表示广义表，用小写字母表示原子



当广义表非空时，第一个元素$a_1$ 为表头 `Head`，其余元素组成的表 $a_2, a_3, \cdots , a_n$ 是广义表的表尾 `Tail`



由于广义表的元素之间结构可能不同，一般使用链式存储对广义表进行存储





### 二叉排序树的插入、构造、删除

`Binary Sort Tree`

> - 若左子树非空，则左子树上所有节点的值均小于根节点的值
> - 若右子树非空，则右子树上所有节点的值均大于跟节点的值
> - 左、右子树也分别是一棵二叉排序树
>
> 因此对二叉排序树进行 **中序遍历** 可以得到一个递增的有序序列



#### 二叉排序树的查找

从根节点开始进行比对，若小于则在左子树上继续重复上述过程，若大于则在右子树上重复上述过程

显然这个过程是递归的，但是仍可以用非递归的思路写 下面给出`Java`实现的参考代码

```java
public BSTNode BSTSearch(BSTNode root, int key){
    BSTNode currentNode = root;
    while(currentNode != null && currentNode.value != key){
        if(key < currentNode.value) currentNode = currentNode.getLeft();
        else currentNode = currentNode.getRight();
    }
    return root;
}
```



#### 二叉排序树的插入

二叉排序树是一种动态树表，其结构通常不是一次生成的，而是在查找过程中，当树中不存在给定值时再进行插入的



- 若原二叉树为空，则直接插入节点
- 若不为空
  - 关键字小于根节点值，则插入到左子树
  - 关键字大于根节点值，则插入到右子树



插入的节点一定时一个新添加的叶节点



#### 二叉排序树的建立

从空树出发，依次把所有的元素插入到二叉排序树中合适的位置



#### 二叉排序树的删除

根据待删除节点的位置，分几种情况处理



- 若节点是叶节点，则直接删除
- 若该节点有一棵左子树或右子树，则让子树成为该节点的父节点的子树，即替代该节点
- 若节点同时有左右子树，则令该节点的 **直接后继 \ 直接前驱** 替代该节点，接着从二叉排序树中删除这个 **直接后继 \ 直接前驱** 就转换成了上述的两种情况之一



#### 二叉排序树的查找效率分析

二叉排序树的查找效率主要取决于 **树的高度**

若二叉排序树的左右子树高度差不超过 `1` 则称为平衡二叉树 此时平均查找长度为 $O(log_2n)$

若是只有左或右孩子的单支树 则平均查找长度为 $O(n)$

对于确定的一个二叉排序树，等概率的平均查找长度为
$$
ASL = \frac{ \sum\limits^h_{i=1} (i*n_i)} {n_{all}}
$$
其中

- $h$ 表示树的高度
- $n_i$表示第$i$个高度下有的节点个数
- $n_{all}$表示所有节点的个数



从查找过程上看，二叉排序树与二分查找类似

就平均时间性能而言，二叉排序树和二分查找差不多

但是二分查找的判定树是唯一的，而二叉排序树的查找不唯一





### 散列存储解决冲突的步骤和思路

散列函数的解决冲突的方法大致上分为两类，**开放地址法** **拉链法**



开放地址法中，其数学推导公式为
$$
H_i = (H(key) + d_i) \% m
$$
其中 $H(key)$ 为散列函数 $i= 0,1,2,\cdots ,k(k \leq m-1)$  ; $m$ 表示散列表表长 ; $d_i$ 为增量序列



- 线性探测法

  > 当 $d_i = 0,1,2, \cdots , m-1$ 时 称为线性探测法
  >
  > 特点 : 当冲突发生时，顺序查看表中的下一个单元 当探测到表尾地址 `m-1` 时下一个探测地址是表首地址 `0`
  >
  > 线性探测可能会让 第 `i` 个散列地址的同义词存入第 `i+1` 个散列地址的元素的地址，本应该存入`i+1` 个散列地址的元素就争夺第 `i+2` 个散列地址的元素的地址
  >
  > 从而造成大量元素再相邻的散列地址上 **聚集** 起来，大大降低了查找效率
  >
  > 

- 平方探测法 \ 二次探测法

  > 当 $d_i = 0^2 , 1^2,-1^2,2^2,-2^2,\dots ,k^2,-k^2$ 时，称为平方探测法 其中 $k \leq \frac{m}{2}$
  >
  > 其散列表的长度需保证为 $m = 4k +3$ 的素数
  >
  > 这种方法可以避免 **堆积** 问题，但是缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元

- 再散列法 \ 双散列法

  > 当 $d_i = Hash_2(key)$ 时，称为再散列法
  >
  > 其计算公式为
  > $$
  > H_i = (H(key) + i \times Hash_2(key)) \% m
  > $$
  > 初始探测位置 $H_0 = H(key) \% m$
  >
  > $i$ 是发生冲突的次数，初始为 0
  >
  > 最多经过 `m-1` 次探测就会遍历表中所有的位置，回到 $H_0$

- 伪随机序列法

  > 当 $d_i$ 是伪随机序列时



:warning: 注意

> 开放地址的情况下，不能随意删除表中的已有元素
>
> 若删除则会截断其他具有相同散列地址的元素的查找地址
>
> 因此要删除一个元素时，应做一个标记，做逻辑删除
>
> 但这样做的副作用会使表看起来很满，实际上仍有许多空间未利用
>
> 因此需要定期维护散列表，把删除标记的元素进行物理删除



### 排序方法的效率以及初始状态相关性



::: warning 注意

 `TC` = `Time Complexity`

`SC` = `Space Complexity`

:::



|   算法种类   |   TC - Best    |  TC - Average  |   TC - Worst   |      SC       | 稳定性 | 初始状态相关性 |
| :----------: | :------------: | :------------: | :------------: | :-----------: | :----: | :------------: |
| 直接插入排序 |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$     |  Yes   |    Related     |
|   冒泡排序   |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$     |  Yes   |    Related     |
| 简单选择排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$     |   No   |   Irrelevant   |
|   希尔排序   |       -        |       -        |       -        |    $O(1)$     |   No   |       -        |
|   快速排序   | $O(n\log_2 n)$ | $O(n\log_2 n)$ |    $O(n^2)$    | $O(\log_2 n)$ |   No   |    Related     |
|    堆排序    | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ |    $O(1)$     |   No   |   Irrelevant   |
| 2路归并排序  | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ |    $O(n)$     |  Yes   |   Irrelevant   |
|   基数排序   |  $O(d(n+r))$   |  $O(d(n+r))$   |  $O(d(n+r))$   |    $O(r)$     |  Yes   |    Related     |



与初始状态无关的四种算法

> 一堆（**堆排序**）乌龟（**归并排序**）选（**选择排序**）基（**基数排序**）友。



### 单链表有无头节点的判空条件及相关操作和特点

#### 头指针与头节点的区分

以下内容需要有对 `C \ C++` 语言中指针的理解，用`Java`不太好理解

一般是使用 头指针 来表示一个单链表 ，若头指针为 `NULL` 时表示空表

一般会在 **第一个节点之前添加一个头节点** 该节点 **不存储任何数据 仅有指针域**

头指针指向该头节点

引入头节点的好处有2点

- 操作链表的第一个数据节点与操作其他节点是一致的，不需要做特别的处理
- 无论链表是否为空，头节点都是指向头节点的非空指针 （空表 中 头节点的指针域为 `NULL` ）因此空表和非空表的操作是统一的



#### 有关操作

|  操作名称  | 时间复杂度 | 备注                 |
| :--------: | ---------- | -------------------- |
| 按序号查找 | $O(n)$     |                      |
|  按值查找  | $O(n)$     |                      |
|  插入节点  | $O(n)$     | 主要时间消耗在查找上 |
|  删除节点  | $O(n)$     | 主要时间消耗在查找上 |
|   求表长   | $O(n)$     | 遍历                 |



### 线性表在链式\顺序存储下的特点和增删查的效率

#### 顺序存储

**逻辑顺序与其物理顺序相同**

随机读取



| 操作 | 时间复杂度 - Best | 时间复杂度 - Average | 时间复杂度 - Worst |
| :--: | :---------------: | :------------------: | :----------------: |
| 插入 |      $O(1)$       |        $O(n)$        |       $O(n)$       |
| 删除 |      $O(1)$       |        $O(n)$        |       $O(n)$       |
| 查找 |      $O(1)$       |        $O(n)$        |       $O(n)$       |



#### 链式存储

插入删除不需要移动元素，但也失去了随机存取的特点

因为其每个节点至少需要 **数据域 + 指针域** 因此消耗的空间比顺序存储大一些

其操作和时间复杂度等请参考上方 [链式存储的操作相关](#有关操作)



### Huffman树的节点数问题

- Huffman 树种不存在 度为 `1` 的结点
- 若有`n`个节点待构建成`Huffman`树 最后构建完的总节点数为 `2n-1`



### 顺序查找的特点

这种查找非常的直观且很容易实现

即从头开始找到尾，这意味着顺序查找可以在顺序表也可以在链式表中使用

这里强调一下 **哨兵** 的作用

将所有待查找元素的前面放置一个 **哨兵**

顺序查找的时候从后往前找，不必担心数组是否会越界的问题



其平均查找长度如下

对于有`n`个元素的表，给定值`key`与表中第`i`个元素的值相等，即定位到第`i`个元素时，需进行`n-i+1`值的比较， $C_i = n-i+1$
$$
ASL_{success} = \sum^n_i P_i(n-i+1)
$$
当每个元素被查找到的概率都相等 即 $P_i = \frac{1}{n}$ 时 有
$$
ASL_{success} = \sum^n_i P_i(n-i+1) = \frac{n+1}{2}
$$
显然
$$
ASL_{failure} = n +1
$$


#### 有序表的顺序查找

若在查找之前已知表中的关键字为有序，则对于表中没有的数据值，即查找失败的处理会比上述的方法查找的长度减小很多

若每个值的查找概率相等
$$
ASL_{failure} = \sum^n_{j=1}q_i(l_j-1)= \frac{n}{2} + \frac{n}{n+1}
$$




### 图的 DFS BFS 与树的遍历方式的联系

#### Breadth First Search 广度优先搜索

类似于 二叉树的 **层序遍历算法**



#### Depth First Search 深度优先搜索

类似于树的 **先序遍历**





### 插入\选择\交换排序的特点

对于具体算法的复杂度等请参考 [排序算法复杂度](#排序方法的效率以及初始状态相关性)

#### 插入排序

插入排序是一种简单直观的排序方法

基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排序好的子序列中

包含三个重要的算法

- 直接插入排序
- 折半插入排序
- 希尔排序



#### 选择排序

基本思想是每第`i`趟在后面 `n-i+1` 个待排序元素中选取关键字最小的元素，作为有序序列的第`i`的元素

直到第 `n-1`趟完成 

其中有 **堆排序** **简单选择排序**



#### 交换排序

所谓交换，指的是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置

基于交换的排序算法很多，书中介绍了 **冒泡排序** 和 **快速排序**



### 稀疏矩阵的三元组

矩阵中非零元素的个数`t` 相对矩阵元素的个数 `s` 来说非常少 即 `s >> t` 的矩阵成为稀疏矩阵

若采用常规的方法存储稀疏矩阵，则非常的浪费空间

因此仅存储非零元素 

但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储其所在的行和列

因此可以使用 三元组（行标，列标，值）的方式存储

既可以采用数组存储，也可以使用十字链表法存储

二维数组在这不做赘述

---

对于十字链表法，每个节点可设置其域为`(row,col,value),down,right`

其中`(row,col,value)`即为三元组的三个值

`down` 指向同列·中相邻行的下一个节点

`right` 指向同行中相邻列的下一个节点

其牺牲了空间换来了一定的效率



### 二叉树遍历结果进行还原

可以确定唯一的二叉树 : 

- 先序序列 中序序列

先序序列中，第一个节点肯定是根节点，中序序列中，根节点必然是将该序列分成两个子序列

重复上述过程，不断递归下去，即可还原

- 后序序列 中序序列

类似的，后续序列中的最后一个元素肯定是根节点，剩下与上一种形式一致即可还原

- 层序序列 中序序列                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           



### Huffman树的特点和编码的应用

#### Huffman树的定义

> 从树的根到任意结点的路径长度与该结点权值的乘积，称为该点的 **带权路径长度** 树中所有叶结点的带权路径长度之和称为该树的 **带权路径长度**

$$
WPL = \sum^n_{i=1}w_il_i
$$

$w_i$ 是第`i`个叶结点所带的权值  $l_i$ 是该叶结点到根结点的路径长度

在含有`n`个结点的二叉树中，带权路径长度最小的二叉树称为 **Huffman树** 也称最优二叉树

#### Huffman树的构造

给定`n`个权值分别为 $w_1,w_2,\cdots , w_n$的结点，构造Huffman树的算法描述如下

1. 将这`n`个结点分别作为`n`课只包含一个结点的二叉树，构成森林`F`
2. 构造一个新的结点，从`F`中选取两颗结点权值最小的树作为新结点的左右子树，并将新节点的权值置为左右子树上根结点的权值之和
3. 从`F`中删除刚才选的两棵树，同时将新得到的树放入其中
4. 重复 第 `2 3` 步 直到森林中只剩下一棵树为止

> 若有若干权值相同的结点，则构造出的Huffman树可能不同，但`WPL`必然相同且最优



#### Huffman树的特点

- 每个初始结点最终都成为了 **叶子结点** 且权值越小的结点到根结点的路径长度越大
- 构造过程中一共新建了 `n-1` 个结点，因此Huffman树的结点总数为 `2n-1`
- Huffman树中不存在度为`1`的结点



#### Huffman编码

Huffman编码是一种对不同的字符用不等长的二进制位表示的编码，称为 **可变长度编码** 

因此方式可以对频率高的字符赋以短编码，对频率低的字符则赋以较长的编码，从而使字符的平均编码长度缩短，起到压缩数据的效果

> 没有一个编码是另一个编码的前缀，这样的编码称为 **前缀编码**

对前缀编码的翻译很简单，因为字符串的翻译结果具有唯一性

对于 `0`  `1` 表示是左子树还是右子树没有明确的规定，因为左右孩子结点的顺序是任意的，因此构造出的Huffman树并不唯一，但`WPL`相同且为最优的





### 邻接表

当图为稀疏图时，使用邻接矩阵法很浪费存储空间，而图的邻接表法结合了顺序存储和链式存储，大大减少了不必要的空间浪费

所谓邻接表，指的是先用顺序表存储图的所有顶点，称为 **顶点表**

顶点表中每一个值的域为 `data` 数据域 `firstEdge` 指向边的指针域

顺序表中每一个元素即每一个单链表的头结点

单链表中每个值的域为 `adjvex`邻接点域 `nextEdge`指向下一条边的指针域



#### 邻接表的特点

由邻接表的构成的特点可知其有如下特点

- 若为无向图 则需要空间 $O(|V| + 2|E|)$
- 若为有向图 则需要空间 $O(|V| + |E|)$
- 对于稀疏图可极大的节省存储空间
- 给定一顶点，很容易找到他的邻边，但是在邻接矩阵中则需要扫描一行 即需要$O(n)$ 的时间
- 确定两点之间是否存在边，邻接矩阵则可以立刻查到，但邻接表查找效率会非常低
- 给定一顶点求其出度只需要计算邻接表中结点的个数，堵车求其入度则需要遍历整个表
- 邻接表的表示方法不唯一，因为在链表部分的结点之间顺序是可以任意的



### Prim算法的应用

Prim算法的思路如下

> 初始时选择图中任意一顶点加入树 T
>
> 此时 T 中只有一个顶点，之后选择一个与当前 T 中顶点集合距离最近的顶点，并将该顶点和对应的边加入 T 中
>
> 每次操作都会使顶点数和边数增加 1
>
> 重复上述步骤，直到图中所有的顶点都加入 T
>
> 此时 T 中必然有 `n-1` 条边



Prim算法的时间复杂度为 $O(|V|^2)$ 其不依赖于边的数量

因此Prim算法适合求解 **边稠密的图** 的最小生成树问题



### Hash表的建立过程

#### 散列表的基本概念

- 散列函数

  > $Hash(key) = Address$
  >
  > 这里的地址可以是数组下标，索引或者内存地址等

- 散列表

  > 根据关键字而直接访问的数据结构
  >
  > 散列表构建了 **关键字和存储地址之间的一种直接映射关系**

理想情况下 散列表的查找时间复杂度应该是 $O(1)$ 不过基本上是不存在的，大部分情况都会有冲突的发生，那么就需要解决冲突

解决冲突请参阅 [线性探测解决冲突的步骤和思路](#线性探测解决冲突的步骤和思路)



#### 散列函数的构造方法

在构造时，需注意以下几点

- 散列函数的定义域需**包括全部所需要的关键字**，而值域的范围则依赖于散列表的大小和地址范围
- 散列函数计算出来的地址应该能够**等概率、均匀的**分布在整个地址空间中，从而减小发生冲突的可能性
- 散列函数应该**尽量简单**，在较短的时间就可以计算出来结果



常用的几种散列函数如下

1. 直接定址法

   > 直接取某个关键字的某个线性函数值为散列地址，散列函数为
   > $$
   > H(key) = key \quad or \quad H(key) = a \times key + b
   > $$
   > `a b` 均为常数
   >
   > 这种计算方法简单，且不会产生冲突
   >
   > 适合关键字分布基本连续的情况
   >
   > 若关键字分布不连续，则会造成空间的浪费

2. 除留余数法

   > 假定散列表的表长为 `m`  取一个不大于`m`但是最接近或等于`m`的质数`p`
   > $$
   > H(key) = key \% p
   > $$
   > 关键在于选取的 `p` 值，该值的好坏直接影响了能否等概率的映射到散列空间的任一地址上，减少冲突的可能性

3. 数字分析法

   > 若关键字是 `r` 尽职数，且`r`个数码在各位上出现的频率不一定相同，
   >
   > 可能在某些位上分布均匀一些，每种数码出现的机会均等
   >
   > 可能在某些位上经常出现，分布不均匀
   >
   > 应选取数码分布比较均匀的若干位作为散列地址
   >
   > 这种方法适合于已知关键字的集合，若更换了关键字，则需要重新构造

4. 平方取中法

   > 取关键字的平方值的中间几位作为散列地址
   >
   > 这种方法得到的散列地址与关键字的每位都有关系，因此散列地址分布比较均匀
   >
   > 适用于关键字的每位取值都不够均匀或小于散列地址所需要的位数



不同情况下，每种构造的散列函数的性能各不相同，应视情况而选择合适的散列函数



### 堆排序\快速排序\希尔排序 的应用和特点

对于算法的时间空间复杂度等信息，请参阅 [排序方法的效率以及初始状态相关性](#排序方法的效率以及初始状态相关性)



对于问题进行排序算法的选择应考虑以下情况

1. 考虑的因素

   > 1. 待排序的元素数量 $n$
   > 2. 元素本身的信息量大小
   > 3. 关键字的结构和分布情况
   > 4. 稳定性的要求
   > 5. 存储结构、辅助空间的大小等要求

2. 排序算法小结

   > 1. 若 $n$ 较小，则选择**直接插入排序**或者**简单选择排序**即可
   >
   >    若元素本身的信息量比较大时，适用简单选择排序比较好，因为插入排序需要移动的次数多
   >
   > 2. 若待排序的元素已经基本有序，选择**直接插入排序**或**冒泡排序**
   >
   > 3. 若 $n$ 较大 则应选择复杂度为 $O(n \log _2n)$ 的算法 **快速排序、堆排序、归并排序**
   >
   >    快速排序被认为是目前排序算法中最好的方法，当关键字随机分布时，该方法的平均时间最短
   >
   >    堆排序所需要的辅助空间比快速排序少，若对空间有一定要求的时候，可以选择堆排序
   >
   >    归并排序相比以上两种，具有稳定性的特点，适用于对稳定性有要求的情况



## 习题归纳

### 栈

